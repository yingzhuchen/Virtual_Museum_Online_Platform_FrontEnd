/* tslint:disable */
/* eslint-disable */
/**
 * 后端接口
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime'
import type {
  AddAnnotationRequest,
  AnnotationResponse,
  CreateScene400Response,
  EditAnnotationRequest1,
  ListAnnotationResponse,
  ListCarouselImage400Response,
  OrderAnnotationRequest,
  UploadIntroductionImage200Response,
  UploadVideo200Response,
} from '../models/index'
import {
  AddAnnotationRequestFromJSON,
  AddAnnotationRequestToJSON,
  AnnotationResponseFromJSON,
  AnnotationResponseToJSON,
  CreateScene400ResponseFromJSON,
  CreateScene400ResponseToJSON,
  EditAnnotationRequest1FromJSON,
  EditAnnotationRequest1ToJSON,
  ListAnnotationResponseFromJSON,
  ListAnnotationResponseToJSON,
  ListCarouselImage400ResponseFromJSON,
  ListCarouselImage400ResponseToJSON,
  OrderAnnotationRequestFromJSON,
  OrderAnnotationRequestToJSON,
  UploadIntroductionImage200ResponseFromJSON,
  UploadIntroductionImage200ResponseToJSON,
  UploadVideo200ResponseFromJSON,
  UploadVideo200ResponseToJSON,
} from '../models/index'

export interface AddAnnotationOperationRequest {
  addAnnotationRequest?: AddAnnotationRequest
}

export interface EditAnnotationRequest {
  editAnnotationRequest1?: EditAnnotationRequest1
}

export interface GetAnnotationDetailsRequest {
  annotationId: number
}

export interface ListAnnotationRequest {
  sceneId: number
}

export interface OrderAnnotationOperationRequest {
  orderAnnotationRequest?: OrderAnnotationRequest
}

export interface RemoveAnnotationRequest {
  annotationId?: number
}

export interface UploadIntroductionImageRequest {
  jpgFile: Blob
}

export interface UploadVideoRequest {
  videoFile: Blob
}

/**
 *
 */
export class AnnotationApi extends runtime.BaseAPI {
  /**
   * 非场景管理员在发送添加场景标记请求时，应该返回无权限异常。
   * 创建标记
   */
  async addAnnotationRaw(
    requestParameters: AddAnnotationOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<AnnotationResponse>> {
    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token('bearer', [])

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request(
      {
        path: `/scene/annotation/add`,
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: AddAnnotationRequestToJSON(requestParameters['addAnnotationRequest']),
      },
      initOverrides,
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      AnnotationResponseFromJSON(jsonValue),
    )
  }

  /**
   * 非场景管理员在发送添加场景标记请求时，应该返回无权限异常。
   * 创建标记
   */
  async addAnnotation(
    addAnnotationRequest?: AddAnnotationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<AnnotationResponse> {
    const response = await this.addAnnotationRaw(
      { addAnnotationRequest: addAnnotationRequest },
      initOverrides,
    )
    return await response.value()
  }

  /**
   *
   * 修改标记
   */
  async editAnnotationRaw(
    requestParameters: EditAnnotationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<AnnotationResponse>> {
    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token('bearer', [])

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request(
      {
        path: `/scene/annotation/edit`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: EditAnnotationRequest1ToJSON(requestParameters['editAnnotationRequest1']),
      },
      initOverrides,
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      AnnotationResponseFromJSON(jsonValue),
    )
  }

  /**
   *
   * 修改标记
   */
  async editAnnotation(
    editAnnotationRequest1?: EditAnnotationRequest1,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<AnnotationResponse> {
    const response = await this.editAnnotationRaw(
      { editAnnotationRequest1: editAnnotationRequest1 },
      initOverrides,
    )
    return await response.value()
  }

  /**
   *
   * 获取单个标记详情
   */
  async getAnnotationDetailsRaw(
    requestParameters: GetAnnotationDetailsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<AnnotationResponse>> {
    if (requestParameters['annotationId'] == null) {
      throw new runtime.RequiredError(
        'annotationId',
        'Required parameter "annotationId" was null or undefined when calling getAnnotationDetails().',
      )
    }

    const queryParameters: any = {}

    if (requestParameters['annotationId'] != null) {
      queryParameters['annotationId'] = requestParameters['annotationId']
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token('bearer', [])

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request(
      {
        path: `/scene/annotation/getInfo`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      AnnotationResponseFromJSON(jsonValue),
    )
  }

  /**
   *
   * 获取单个标记详情
   */
  async getAnnotationDetails(
    annotationId: number,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<AnnotationResponse> {
    const response = await this.getAnnotationDetailsRaw(
      { annotationId: annotationId },
      initOverrides,
    )
    return await response.value()
  }

  /**
   * 返回的数据包含了annotationData。在后续修改标记的时候，比如传送点，前端页面会弹出该点的绑定信息，用于警告用户修改会覆盖原始数据。
   * 获取标记列表
   */
  async listAnnotationRaw(
    requestParameters: ListAnnotationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<ListAnnotationResponse>> {
    if (requestParameters['sceneId'] == null) {
      throw new runtime.RequiredError(
        'sceneId',
        'Required parameter "sceneId" was null or undefined when calling listAnnotation().',
      )
    }

    const queryParameters: any = {}

    if (requestParameters['sceneId'] != null) {
      queryParameters['sceneId'] = requestParameters['sceneId']
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token('bearer', [])

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request(
      {
        path: `/scene/annotation/list`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ListAnnotationResponseFromJSON(jsonValue),
    )
  }

  /**
   * 返回的数据包含了annotationData。在后续修改标记的时候，比如传送点，前端页面会弹出该点的绑定信息，用于警告用户修改会覆盖原始数据。
   * 获取标记列表
   */
  async listAnnotation(
    sceneId: number,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<ListAnnotationResponse> {
    const response = await this.listAnnotationRaw({ sceneId: sceneId }, initOverrides)
    return await response.value()
  }

  /**
   * 返回的标记点列表为排序后的列表
   * 修改排序
   */
  async orderAnnotationRaw(
    requestParameters: OrderAnnotationOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<ListAnnotationResponse>> {
    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token('bearer', [])

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request(
      {
        path: `/scene/annotation/order`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: OrderAnnotationRequestToJSON(requestParameters['orderAnnotationRequest']),
      },
      initOverrides,
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ListAnnotationResponseFromJSON(jsonValue),
    )
  }

  /**
   * 返回的标记点列表为排序后的列表
   * 修改排序
   */
  async orderAnnotation(
    orderAnnotationRequest?: OrderAnnotationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<ListAnnotationResponse> {
    const response = await this.orderAnnotationRaw(
      { orderAnnotationRequest: orderAnnotationRequest },
      initOverrides,
    )
    return await response.value()
  }

  /**
   * 用户发送请求后，annotaitonId映射到sceneId，检查用户是否是对应sceneId的场景管理员，如果不是，返回无权限异常。
   * 删除标记
   */
  async removeAnnotationRaw(
    requestParameters: RemoveAnnotationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<object>> {
    const queryParameters: any = {}

    if (requestParameters['annotationId'] != null) {
      queryParameters['annotationId'] = requestParameters['annotationId']
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token('bearer', [])

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request(
      {
        path: `/scene/annotation/remove`,
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    )

    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * 用户发送请求后，annotaitonId映射到sceneId，检查用户是否是对应sceneId的场景管理员，如果不是，返回无权限异常。
   * 删除标记
   */
  async removeAnnotation(
    annotationId?: number,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<object> {
    const response = await this.removeAnnotationRaw({ annotationId: annotationId }, initOverrides)
    return await response.value()
  }

  /**
   * #### 要求限制文件大小20MB以内
   * 介绍点上传图片
   */
  async uploadIntroductionImageRaw(
    requestParameters: UploadIntroductionImageRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<UploadIntroductionImage200Response>> {
    if (requestParameters['jpgFile'] == null) {
      throw new runtime.RequiredError(
        'jpgFile',
        'Required parameter "jpgFile" was null or undefined when calling uploadIntroductionImage().',
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token('bearer', [])

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const consumes: runtime.Consume[] = [{ contentType: 'multipart/form-data' }]
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes)

    let formParams: { append(param: string, value: any): any }
    let useForm = false
    // use FormData to transmit files using content-type "multipart/form-data"
    useForm = canConsumeForm
    if (useForm) {
      formParams = new FormData()
    } else {
      formParams = new URLSearchParams()
    }

    if (requestParameters['jpgFile'] != null) {
      formParams.append('jpgFile', requestParameters['jpgFile'] as any)
    }

    const response = await this.request(
      {
        path: `/scene/upload/image`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: formParams,
      },
      initOverrides,
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      UploadIntroductionImage200ResponseFromJSON(jsonValue),
    )
  }

  /**
   * #### 要求限制文件大小20MB以内
   * 介绍点上传图片
   */
  async uploadIntroductionImage(
    jpgFile: Blob,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<UploadIntroductionImage200Response> {
    const response = await this.uploadIntroductionImageRaw({ jpgFile: jpgFile }, initOverrides)
    return await response.value()
  }

  /**
   * #### 要求限制视频大小20MB以内，目前限制格式为MP4，建议在前端写明
   * 介绍点上传视频
   */
  async uploadVideoRaw(
    requestParameters: UploadVideoRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<UploadVideo200Response>> {
    if (requestParameters['videoFile'] == null) {
      throw new runtime.RequiredError(
        'videoFile',
        'Required parameter "videoFile" was null or undefined when calling uploadVideo().',
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token('bearer', [])

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const consumes: runtime.Consume[] = [{ contentType: 'multipart/form-data' }]
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes)

    let formParams: { append(param: string, value: any): any }
    let useForm = false
    // use FormData to transmit files using content-type "multipart/form-data"
    useForm = canConsumeForm
    if (useForm) {
      formParams = new FormData()
    } else {
      formParams = new URLSearchParams()
    }

    if (requestParameters['videoFile'] != null) {
      formParams.append('videoFile', requestParameters['videoFile'] as any)
    }

    const response = await this.request(
      {
        path: `/scene/upload/video`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: formParams,
      },
      initOverrides,
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      UploadVideo200ResponseFromJSON(jsonValue),
    )
  }

  /**
   * #### 要求限制视频大小20MB以内，目前限制格式为MP4，建议在前端写明
   * 介绍点上传视频
   */
  async uploadVideo(
    videoFile: Blob,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<UploadVideo200Response> {
    const response = await this.uploadVideoRaw({ videoFile: videoFile }, initOverrides)
    return await response.value()
  }
}
